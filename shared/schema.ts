import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp, integer, boolean, decimal } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  walletAddress: text("wallet_address").unique(),
  username: text("username").notNull(),
  email: text("email"),
  avatar: text("avatar"),
  // New three-token economy: Viator ($1), Kairos (raffle tickets), Raivan (rewards)
  viatorTokens: decimal("viator_tokens", { precision: 10, scale: 2 }).notNull().default("0"), // Strong token ($1 USD value)
  kairosTokens: integer("kairos_tokens").notNull().default(0), // Raffle ticket tokens (18 Raivan = 1 Kairos)
  raivanTokens: integer("raivan_tokens").notNull().default(0), // Reward tokens earned from activities
  level: integer("level").notNull().default(1),
  totalMissionsCompleted: integer("total_missions_completed").notNull().default(0),
  stripeCustomerId: text("stripe_customer_id").unique(),
  createdAt: timestamp("created_at").defaultNow(),
});

export const missions = pgTable("missions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  title: text("title").notNull(),
  description: text("description").notNull(),
  type: text("type").notNull(), // cultural, local, sports, travel
  reward: integer("reward").notNull(), // tokens awarded
  difficulty: text("difficulty").notNull(), // easy, medium, hard
  location: text("location"), // optional location theme
  icon: text("icon").notNull(),
  verificationMethod: text("verification_method").notNull().default("auto"), // auto, manual, proof_required, time_based
  verificationCriteria: text("verification_criteria"), // JSON string with specific criteria
  completionTimeLimit: integer("completion_time_limit"), // minutes to complete after starting
  requiredProofType: text("required_proof_type"), // photo, text, location, none
  autoCompleteDelay: integer("auto_complete_delay").default(0), // seconds before auto-completion
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

export const userMissions = pgTable("user_missions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  missionId: varchar("mission_id").notNull().references(() => missions.id),
  status: text("status").notNull().default("active"), // active, in_progress, pending_verification, completed, failed, claimed
  startedAt: timestamp("started_at"),
  completedAt: timestamp("completed_at"),
  verificationData: text("verification_data"), // JSON string with proof/verification info
  tokensAwarded: integer("tokens_awarded").default(0),
  verificationStatus: text("verification_status").default("none"), // none, pending, approved, rejected
  verifiedBy: text("verified_by"), // system, admin, or verification method
  createdAt: timestamp("created_at").defaultNow(),
});

export const lotteries = pgTable("lotteries", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  title: text("title").notNull(),
  description: text("description").notNull(),
  theme: text("theme").notNull(), // destination theme like "Paris Adventure", "Tokyo Explorer"
  prizeTitle: text("prize_title").notNull(),
  prizeDescription: text("prize_description").notNull(),
  prizeValue: integer("prize_value").notNull(), // USD value in cents
  ticketPrice: integer("ticket_price").notNull(), // tokens required per entry
  maxTickets: integer("max_tickets").notNull(),
  soldTickets: integer("sold_tickets").notNull().default(0),
  drawDate: timestamp("draw_date").notNull(),
  status: text("status").notNull().default("active"), // active, drawn, completed
  winnerId: varchar("winner_id").references(() => users.id),
  image: text("image").notNull(),
  lotteryCode: text("lottery_code").unique(), // Human-readable lottery code like "LT2025-001"
  createdAt: timestamp("created_at").defaultNow(),
});

export const lotteryTickets = pgTable("lottery_tickets", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  lotteryId: varchar("lottery_id").notNull().references(() => lotteries.id),
  userId: varchar("user_id").notNull().references(() => users.id),
  ticketNumber: integer("ticket_number").notNull(),
  selectedNumbers: text("selected_numbers").array().notNull(),
  isAutoGenerated: boolean("is_auto_generated").notNull().default(false),
  ticketCode: text("ticket_code").unique(), // Human-readable ticket code like "TK-2025-001-0001"
  isWinningTicket: boolean("is_winning_ticket").notNull().default(false),
  winnerQrCode: text("winner_qr_code"), // QR code for winning ticket verification
  purchasedAt: timestamp("purchased_at").defaultNow(),
});

// Dedicated table for tracking all lottery draws with unique IDs
export const lotteryDraws = pgTable("lottery_draws", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  drawCode: text("draw_code").unique().notNull(), // Human-readable draw code like "DRW-2025-001-TK"
  lotteryId: varchar("lottery_id").notNull().references(() => lotteries.id),
  winningTicketId: varchar("winning_ticket_id").references(() => lotteryTickets.id),
  winnerId: varchar("winner_id").references(() => users.id),
  winningNumbers: text("winning_numbers").array(),
  totalTicketsSold: integer("total_tickets_sold").notNull(),
  drawExecutorId: varchar("draw_executor_id"), // ID of admin/system that executed draw
  verificationHash: text("verification_hash"), // Cryptographic hash for draw verification
  winnerQrCode: text("winner_qr_code"), // QR code data for winning ticket verification
  drawData: text("draw_data"), // JSON with additional draw metadata
  drawnAt: timestamp("drawn_at").defaultNow(),
});

// Mission activity tracking with unique IDs for each activity
export const missionActivities = pgTable("mission_activities", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  activityId: varchar("activity_id").unique().notNull().default(sql`gen_random_uuid()`), // Always accessible unique activity ID
  userMissionId: varchar("user_mission_id").notNull().references(() => userMissions.id),
  userId: varchar("user_id").notNull().references(() => users.id),
  missionId: varchar("mission_id").notNull().references(() => missions.id),
  activityType: text("activity_type").notNull(), // start, progress_update, completion_attempt, verification_submitted, verified, failed
  activityData: text("activity_data"), // JSON with activity-specific data
  locationData: text("location_data"), // GPS coordinates if applicable
  proofData: text("proof_data"), // Photos, text, or other proof submitted
  verificationResult: text("verification_result"), // approved, rejected, pending
  tokenChange: integer("token_change").default(0), // Tokens awarded/deducted for this activity
  isSignificant: boolean("is_significant").notNull().default(true), // Whether this activity should be highlighted
  activityHash: text("activity_hash"), // Cryptographic hash for activity verification
  createdAt: timestamp("created_at").defaultNow(),
});

export const nfts = pgTable("nfts", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  tokenId: text("token_id").unique(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  image: text("image").notNull(),
  rarity: text("rarity").notNull(), // common, rare, epic, legendary
  category: text("category").notNull(), // destination, experience, achievement
  metadata: text("metadata"), // JSON string for additional properties
  ownerId: varchar("owner_id").references(() => users.id),
  isRedeemable: boolean("is_redeemable").notNull().default(false),
  createdAt: timestamp("created_at").defaultNow(),
});

export const prizes = pgTable("prizes", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  title: text("title").notNull(),
  description: text("description").notNull(),
  category: text("category").notNull(), // travel_package, experience, discount, product
  destination: text("destination"), // for travel packages
  value: integer("value").notNull(), // USD value in cents
  tokensRequired: integer("tokens_required").notNull(),
  image: text("image").notNull(),
  provider: text("provider").notNull(), // partner company
  availability: integer("availability").notNull().default(1),
  validUntil: timestamp("valid_until"),
  terms: text("terms"),
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

export const prizeRedemptions = pgTable("prize_redemptions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  prizeId: varchar("prize_id").notNull().references(() => prizes.id),
  status: text("status").notNull().default("pending"), // pending, confirmed, delivered
  redemptionCode: text("redemption_code").unique(),
  redeemedAt: timestamp("redeemed_at").defaultNow(),
});

export const tokenPacks = pgTable("token_packs", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  description: text("description").notNull(),
  tokenAmount: integer("token_amount").notNull(),
  priceUsd: decimal("price_usd", { precision: 10, scale: 2 }).notNull(),
  stripePriceId: text("stripe_price_id"),
  isActive: boolean("is_active").notNull().default(true),
  popularBadge: boolean("popular_badge").notNull().default(false),
  createdAt: timestamp("created_at").defaultNow(),
});

export const tokenPurchases = pgTable("token_purchases", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  tokenPackId: varchar("token_pack_id").notNull().references(() => tokenPacks.id),
  stripePaymentIntentId: text("stripe_payment_intent_id").unique(),
  tokensGranted: integer("tokens_granted").notNull(),
  amountPaid: decimal("amount_paid", { precision: 10, scale: 2 }).notNull(),
  status: text("status").notNull().default("pending"), // pending, completed, failed
  purchasedAt: timestamp("purchased_at").defaultNow(),
});

// Token conversion tracking and limits
export const raivanConversions = pgTable("raivan_conversions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  conversionType: text("conversion_type").notNull(), // "raivan_to_kairos" (18 Raivan = 1 Kairos)
  raivanAmount: integer("raivan_amount").notNull(), // Amount of Raivan tokens converted
  kairosAmount: integer("kairos_amount").notNull(), // Amount of Kairos tokens received
  conversionRate: decimal("conversion_rate", { precision: 10, scale: 6 }).notNull().default("18"), // 18 Raivan = 1 Kairos
  transactionHash: text("transaction_hash"), // For blockchain transactions
  status: text("status").notNull().default("completed"), // pending, completed, failed
  createdAt: timestamp("created_at").defaultNow(),
});

// Token Pack configuration - Updated for new three-token system
// New Token Economy: Viator ($1 USD), Kairos (raffle tickets, 18 Raivan value), Raivan (reward tokens)
export const viatorTokenPacks = pgTable("viator_token_packs", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  description: text("description").notNull(),
  kairosAmount: integer("kairos_amount").notNull(), // Number of Kairos (raffle ticket) tokens
  viatorPrice: decimal("viator_price", { precision: 10, scale: 2 }).notNull(), // Price in Viator tokens
  usdPrice: decimal("usd_price", { precision: 10, scale: 2 }).notNull(), // USD equivalent (1 Viator = $1)
  packType: text("pack_type").notNull(), // "starter", "adventure", "explorer"
  isActive: boolean("is_active").notNull().default(true),
  popularBadge: boolean("popular_badge").notNull().default(false),
  createdAt: timestamp("created_at").defaultNow(),
});

// XP earning activities and achievements
export const raivanActivities = pgTable("raivan_activities", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  activityType: text("activity_type").notNull(), // mission_complete, referral, daily_login, lottery_participate, achievement_unlock
  activityId: varchar("activity_id"), // Mission ID, lottery ID, achievement ID, etc.
  raivanEarned: integer("raivan_earned").notNull(), // Raivan tokens earned from activity
  activityData: text("activity_data"), // JSON with activity details
  isSignificant: boolean("is_significant").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

// Daily conversion limits and tracking
export const userConversionLimits = pgTable("user_conversion_limits", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  conversionType: text("conversion_type").notNull(), // "raivan_to_kairos"
  dailyLimit: integer("daily_limit").notNull().default(360), // Max Raivan convertible per day (20 Kairos worth)
  currentDayUsage: integer("current_day_usage").notNull().default(0),
  lastResetDate: timestamp("last_reset_date").defaultNow(),
  createdAt: timestamp("created_at").defaultNow(),
});

// Achievement unlocks and rewards
export const achievements = pgTable("achievements", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  description: text("description").notNull(),
  type: text("type").notNull(), // mission_based, conversion_based, participation_based, travel_based
  criteria: text("criteria").notNull(), // JSON with unlock criteria
  raivanReward: integer("raivan_reward").notNull().default(0), // Raivan tokens earned
  icon: text("icon").notNull(),
  rarity: text("rarity").notNull().default("common"), // common, rare, epic, legendary
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

// User achievement tracking
export const userAchievements = pgTable("user_achievements", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  achievementId: varchar("achievement_id").notNull().references(() => achievements.id),
  progress: integer("progress").notNull().default(0),
  maxProgress: integer("max_progress").notNull(),
  isUnlocked: boolean("is_unlocked").notNull().default(false),
  unlockedAt: timestamp("unlocked_at"),
  rewardsClaimed: boolean("rewards_claimed").notNull().default(false),
  claimedAt: timestamp("claimed_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

export const serviceConditions = pgTable("service_conditions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  conditionType: text("condition_type").notNull(), // terms_of_service, privacy_policy, operating_conditions
  version: text("version").notNull(),
  title: text("title").notNull(),
  content: text("content").notNull(), // JSON string with sections and rules
  effectiveDate: timestamp("effective_date").notNull(),
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

export const userAgreements = pgTable("user_agreements", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  serviceConditionId: varchar("service_condition_id").notNull().references(() => serviceConditions.id),
  conditionType: text("condition_type").notNull(), // terms_of_service, privacy_policy, operating_conditions
  version: text("version").notNull(),
  agreementStatus: text("agreement_status").notNull().default("pending"), // pending, accepted, revoked
  sectionsAccepted: text("sections_accepted").array(),
  acceptedAt: timestamp("accepted_at"),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Marketplace user-to-user selling and auctions (platform-derived items only)
export const marketplaceListings = pgTable("marketplace_listings", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  sellerId: varchar("seller_id").notNull().references(() => users.id),
  title: text("title").notNull(),
  description: text("description").notNull(),
  category: text("category").notNull(), // experience, travel_package, discount, product, nft, prize_voucher
  listingType: text("listing_type").notNull(), // sell, auction
  startPrice: integer("start_price").notNull(), // Kairos tokens
  buyNowPrice: integer("buy_now_price"), // For auctions with buy-now option
  currentPrice: integer("current_price"), // Current highest bid for auctions
  reservePrice: integer("reserve_price"), // Minimum price for auctions
  // Platform-derived item verification (security guarantee)
  sourceType: text("source_type").notNull(), // prize_redemption, nft_mint, lottery_win, mission_reward
  sourceId: varchar("source_id").notNull(), // ID of original platform item/transaction
  verificationHash: text("verification_hash").notNull(), // Cryptographic proof of platform origin
  // Listing status and timing
  status: text("status").notNull().default("active"), // active, sold, cancelled, expired, pending
  startTime: timestamp("start_time").defaultNow(),
  endTime: timestamp("end_time").notNull(),
  // Media and details
  images: text("images").array().notNull(),
  tags: text("tags").array(),
  terms: text("terms"), // Seller-specific terms
  // Seller performance
  sellerRating: decimal("seller_rating", { precision: 3, scale: 2 }),
  totalViews: integer("total_views").notNull().default(0),
  totalWatchers: integer("total_watchers").notNull().default(0),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Auction bids tracking
export const marketplaceBids = pgTable("marketplace_bids", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  listingId: varchar("listing_id").notNull().references(() => marketplaceListings.id),
  bidderId: varchar("bidder_id").notNull().references(() => users.id),
  bidAmount: integer("bid_amount").notNull(), // Kairos tokens
  bidType: text("bid_type").notNull().default("regular"), // regular, auto_bid, buy_now
  status: text("status").notNull().default("active"), // active, outbid, winning, cancelled
  automaticBidLimit: integer("automatic_bid_limit"), // For auto-bidding
  bidMessage: text("bid_message"), // Optional message from bidder
  ipAddress: text("ip_address"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Purchase transactions for marketplace
export const marketplacePurchases = pgTable("marketplace_purchases", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  listingId: varchar("listing_id").notNull().references(() => marketplaceListings.id),
  sellerId: varchar("seller_id").notNull().references(() => users.id),
  buyerId: varchar("buyer_id").notNull().references(() => users.id),
  purchaseType: text("purchase_type").notNull(), // direct_sale, auction_win, buy_now
  finalPrice: integer("final_price").notNull(), // Kairos tokens
  platformFee: integer("platform_fee").notNull(), // Platform commission in Kairos
  sellerEarnings: integer("seller_earnings").notNull(), // Seller receives after fee
  status: text("status").notNull().default("pending"), // pending, completed, disputed, refunded
  transferStatus: text("transfer_status").notNull().default("pending"), // pending, completed, failed
  transferCode: text("transfer_code").unique(), // Unique code for item transfer
  buyerRating: integer("buyer_rating"), // 1-5 stars
  sellerRating: integer("seller_rating"), // 1-5 stars
  feedback: text("feedback"),
  completedAt: timestamp("completed_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Marketplace watchers/favorites
export const marketplaceWatchers = pgTable("marketplace_watchers", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  listingId: varchar("listing_id").notNull().references(() => marketplaceListings.id),
  notifyOnBid: boolean("notify_on_bid").notNull().default(true),
  notifyOnPriceChange: boolean("notify_on_price_change").notNull().default(true),
  notifyOnEnding: boolean("notify_on_ending").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

// Seller performance and reputation
export const sellerProfiles = pgTable("seller_profiles", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id).unique(),
  totalSales: integer("total_sales").notNull().default(0),
  totalListings: integer("total_listings").notNull().default(0),
  averageRating: decimal("average_rating", { precision: 3, scale: 2 }).default("0.00"),
  totalRatings: integer("total_ratings").notNull().default(0),
  responseTime: integer("response_time").default(0), // Average response time in hours
  completionRate: decimal("completion_rate", { precision: 5, scale: 2 }).default("100.00"),
  sellerBadges: text("seller_badges").array(), // verified, top_seller, fast_shipper, etc.
  sellerLevel: text("seller_level").notNull().default("bronze"), // bronze, silver, gold, platinum
  joinedAsSellerAt: timestamp("joined_as_seller_at").defaultNow(),
  lastActiveAt: timestamp("last_active_at").defaultNow(),
});

// Disputes and resolution
export const marketplaceDisputes = pgTable("marketplace_disputes", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  purchaseId: varchar("purchase_id").notNull().references(() => marketplacePurchases.id),
  complainantId: varchar("complainant_id").notNull().references(() => users.id),
  respondentId: varchar("respondent_id").notNull().references(() => users.id),
  disputeType: text("dispute_type").notNull(), // item_not_received, item_not_as_described, payment_issue
  disputeReason: text("dispute_reason").notNull(),
  evidence: text("evidence"), // JSON with submitted evidence
  status: text("status").notNull().default("open"), // open, under_review, resolved, closed
  resolution: text("resolution"), // admin_decision, mutual_agreement, automatic
  resolutionDetails: text("resolution_details"),
  resolvedBy: varchar("resolved_by").references(() => users.id),
  resolvedAt: timestamp("resolved_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Platform-derived item verification records
export const itemVerifications = pgTable("item_verifications", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  itemId: varchar("item_id").notNull(), // Could be prize, NFT, lottery win, etc.
  itemType: text("item_type").notNull(), // prize_redemption, nft, lottery_ticket, mission_reward
  ownerId: varchar("owner_id").notNull().references(() => users.id),
  verificationStatus: text("verification_status").notNull().default("verified"), // verified, pending, failed
  verificationHash: text("verification_hash").notNull(),
  originalTransactionId: varchar("original_transaction_id"),
  verificationProof: text("verification_proof"), // JSON with verification data
  isTransferable: boolean("is_transferable").notNull().default(true),
  transferHistory: text("transfer_history"), // JSON array of transfer records
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// User favorites system for lotteries, missions, and marketplace items
export const userFavorites = pgTable("user_favorites", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  itemType: text("item_type").notNull(), // lottery, mission, marketplace_item
  itemId: varchar("item_id").notNull(), // ID of the favorite item
  itemTitle: text("item_title").notNull(), // Cached title for display
  itemDescription: text("item_description"), // Cached description
  itemImage: text("item_image"), // Cached image URL
  itemMetadata: text("item_metadata"), // JSON string with additional item data
  createdAt: timestamp("created_at").defaultNow(),
});

// Travel Agency Partnership Module
export const travelAgencies = pgTable("travel_agencies", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  description: text("description"),
  logo: text("logo"),
  website: text("website"),
  email: text("email").notNull(),
  phone: text("phone"),
  address: text("address"),
  city: text("city"),
  region: text("region"), // State/Province/Region within country
  country: text("country").notNull(),
  countryCode: text("country_code").notNull(), // ISO country code (US, CA, MX, etc.)
  timeZone: text("time_zone"), // Agency's local timezone
  coordinates: text("coordinates"), // JSON with lat/lng for geographic distribution
  coverageRadius: integer("coverage_radius"), // Service area radius in kilometers
  territoryCode: text("territory_code"), // Specific territory/zone code within country (T001-T360)
  nationalRanking: integer("national_ranking"), // Agency ranking within country (1-360)
  marketTier: text("market_tier").notNull().default("tier3"), // tier1 (major cities), tier2 (regional), tier3 (local)
  populationDensity: text("population_density"), // high, medium, low - affects capacity and reach
  capacityLimit: integer("capacity_limit").notNull().default(50), // Max concurrent users they can handle
  specialties: text("specialties").array(), // ["adventure", "cultural", "luxury", "budget"]
  rating: decimal("rating", { precision: 3, scale: 2 }), // 0.00 to 5.00
  totalBookings: integer("total_bookings").notNull().default(0),
  commissionRate: decimal("commission_rate", { precision: 5, scale: 4 }).notNull(), // 0.0000 to 1.0000 (percentage)
  status: text("status").notNull().default("active"), // active, suspended, pending
  partnershipType: text("partnership_type").notNull().default("standard"), // standard, premium, exclusive
  apiKey: text("api_key").unique(), // For external system integration
  webhookUrl: text("webhook_url"), // For prize notifications
  contactPersonName: text("contact_person_name"),
  contactPersonEmail: text("contact_person_email"),
  paymentDetails: text("payment_details"), // JSON string with bank/payment info
  createdAt: timestamp("created_at").defaultNow(),
});

export const agencyTourPackages = pgTable("agency_tour_packages", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  agencyId: varchar("agency_id").notNull().references(() => travelAgencies.id),
  title: text("title").notNull(),
  description: text("description").notNull(),
  destination: text("destination").notNull(),
  duration: integer("duration").notNull(), // days
  price: integer("price").notNull(), // USD in cents
  originalPrice: integer("original_price"), // For discount display
  maxParticipants: integer("max_participants").notNull(),
  difficulty: text("difficulty").notNull(), // easy, medium, hard
  category: text("category").notNull(), // cultural, adventure, relaxation, business
  inclusions: text("inclusions").array(), // ["flights", "hotels", "meals", "guide"]
  images: text("images").array(),
  itinerary: text("itinerary"), // JSON string with daily schedule
  requirements: text("requirements"), // special requirements or restrictions
  cancellationPolicy: text("cancellation_policy"),
  seasonality: text("seasonality"), // when available (all-year, summer, winter, etc)
  isActive: boolean("is_active").notNull().default(true),
  isFeatured: boolean("is_featured").notNull().default(false),
  bookingUrl: text("booking_url"), // Direct booking link
  createdAt: timestamp("created_at").defaultNow(),
});

export const prizeWinners = pgTable("prize_winners", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  lotteryId: varchar("lottery_id").references(() => lotteries.id),
  prizeId: varchar("prize_id").references(() => prizes.id),
  prizeType: text("prize_type").notNull(), // lottery, mission_reward, marketplace_redemption
  prizeTitle: text("prize_title").notNull(),
  prizeDescription: text("prize_description"),
  prizeValue: integer("prize_value"), // USD in cents
  assignedAgencyId: varchar("assigned_agency_id").references(() => travelAgencies.id),
  tourPackageId: varchar("tour_package_id").references(() => agencyTourPackages.id),
  status: text("status").notNull().default("pending"), // pending, assigned, contacted, booked, completed, cancelled
  contactInfo: text("contact_info"), // JSON with winner's contact details
  preferredDates: text("preferred_dates"), // JSON array of date ranges
  specialRequests: text("special_requests"),
  bookingReference: text("booking_reference"), // From agency booking system
  agencyNotes: text("agency_notes"), // Internal notes from agency
  communicationLog: text("communication_log"), // JSON array of communications
  claimedAt: timestamp("claimed_at"),
  assignedAt: timestamp("assigned_at"),
  contactedAt: timestamp("contacted_at"),
  bookedAt: timestamp("booked_at"),
  completedAt: timestamp("completed_at"),
  expiresAt: timestamp("expires_at"), // Prize claim deadline
  createdAt: timestamp("created_at").defaultNow(),
});

export const agencyCommissions = pgTable("agency_commissions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  agencyId: varchar("agency_id").notNull().references(() => travelAgencies.id),
  sourceType: text("source_type").notNull(), // tour_package, token_purchase, referral
  sourceId: varchar("source_id").notNull(), // ID of the related record
  userId: varchar("user_id").references(() => users.id), // Customer who made the purchase
  transactionAmount: integer("transaction_amount").notNull(), // Original amount in cents
  commissionRate: decimal("commission_rate", { precision: 5, scale: 4 }).notNull(),
  commissionAmount: integer("commission_amount").notNull(), // Commission in cents
  status: text("status").notNull().default("pending"), // pending, approved, paid, disputed
  paymentReference: text("payment_reference"), // Reference for commission payment
  notes: text("notes"),
  approvedAt: timestamp("approved_at"),
  paidAt: timestamp("paid_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

export const agencyAnalytics = pgTable("agency_analytics", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  agencyId: varchar("agency_id").notNull().references(() => travelAgencies.id),
  date: timestamp("date").notNull(),
  prizesAssigned: integer("prizes_assigned").notNull().default(0),
  prizesCompleted: integer("prizes_completed").notNull().default(0),
  totalCommissions: integer("total_commissions").notNull().default(0), // in cents
  customerSatisfactionScore: decimal("customer_satisfaction_score", { precision: 3, scale: 2 }),
  responseTime: integer("response_time"), // average hours to respond
  conversionRate: decimal("conversion_rate", { precision: 5, scale: 4 }), // assigned to completed
  createdAt: timestamp("created_at").defaultNow(),
});

// Exclusive Affiliate Program Module - Differentiated for Travel Agencies and Individual Users
export const affiliatePrograms = pgTable("affiliate_programs", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  agencyId: varchar("agency_id").notNull().references(() => travelAgencies.id),
  programName: text("program_name").notNull(),
  partnerType: text("partner_type").notNull().default("travel_agency"), // travel_agency, individual_user
  businessScale: text("business_scale"), // enterprise, mid_market, small_business, individual
  uniqueCode: text("unique_code").notNull().unique(), // For referral links
  affiliateLink: text("affiliate_link").notNull(), // Generated unique URL
  commissionTiers: text("commission_tiers").notNull(), // JSON with differentiated volume-based tiers by partner type
  baseCommissionRate: decimal("base_commission_rate", { precision: 5, scale: 4 }).notNull(),
  bonusThresholds: text("bonus_thresholds"), // JSON with milestone bonuses (different thresholds for agencies vs users)
  volumeRequirements: text("volume_requirements"), // JSON with different volume requirements per partner type
  specialBenefits: text("special_benefits").array(), // Enhanced benefits for travel agencies (priority support, custom materials, etc.)
  trackingPixel: text("tracking_pixel"), // For advanced analytics
  landingPageCustomization: text("landing_page_customization"), // JSON with custom branding
  promotionalMaterials: text("promotional_materials"), // JSON with banners, copy, etc.
  status: text("status").notNull().default("active"), // active, paused, suspended
  termsAndConditions: text("terms_and_conditions"),
  payoutSchedule: text("payout_schedule").notNull().default("monthly"), // monthly, quarterly, weekly
  minimumPayout: integer("minimum_payout").notNull().default(5000), // Different minimums for agencies vs users
  isExclusive: boolean("is_exclusive").notNull().default(false),
  exclusivityBonus: decimal("exclusivity_bonus", { precision: 5, scale: 4 }),
  createdAt: timestamp("created_at").defaultNow(),
});

export const affiliateReferrals = pgTable("affiliate_referrals", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  affiliateProgramId: varchar("affiliate_program_id").notNull().references(() => affiliatePrograms.id),
  agencyId: varchar("agency_id").notNull().references(() => travelAgencies.id),
  userId: varchar("user_id").notNull().references(() => users.id),
  referralCode: text("referral_code").notNull(),
  clickedAt: timestamp("clicked_at").notNull(),
  registeredAt: timestamp("registered_at"),
  firstTransactionAt: timestamp("first_transaction_at"),
  firstTransactionAmount: integer("first_transaction_amount"), // in cents
  totalSpent: integer("total_spent").notNull().default(0), // lifetime value in cents
  transactionCount: integer("transaction_count").notNull().default(0),
  status: text("status").notNull().default("clicked"), // clicked, registered, converted, churned
  userAgent: text("user_agent"),
  ipAddress: text("ip_address"),
  source: text("source"), // social media, email, banner, etc.
  campaign: text("campaign"), // specific marketing campaign
  conversionData: text("conversion_data"), // JSON with conversion details
  createdAt: timestamp("created_at").defaultNow(),
});

export const affiliatePayouts = pgTable("affiliate_payouts", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  affiliateProgramId: varchar("affiliate_program_id").notNull().references(() => affiliatePrograms.id),
  agencyId: varchar("agency_id").notNull().references(() => travelAgencies.id),
  payoutPeriodStart: timestamp("payout_period_start").notNull(),
  payoutPeriodEnd: timestamp("payout_period_end").notNull(),
  totalReferrals: integer("total_referrals").notNull(),
  convertedReferrals: integer("converted_referrals").notNull(),
  totalCommissionEarned: integer("total_commission_earned").notNull(), // in cents
  bonusEarned: integer("bonus_earned").notNull().default(0), // in cents
  adjustments: integer("adjustments").notNull().default(0), // in cents (can be negative)
  netPayout: integer("net_payout").notNull(), // in cents
  status: text("status").notNull().default("pending"), // pending, approved, paid, disputed
  paymentMethod: text("payment_method"), // bank_transfer, paypal, check
  paymentReference: text("payment_reference"),
  notes: text("notes"),
  approvedAt: timestamp("approved_at"),
  paidAt: timestamp("paid_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

export const affiliateTrackingEvents = pgTable("affiliate_tracking_events", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  affiliateReferralId: varchar("affiliate_referral_id").notNull().references(() => affiliateReferrals.id),
  eventType: text("event_type").notNull(), // click, register, first_purchase, repeat_purchase, milestone
  eventValue: integer("event_value"), // transaction amount or milestone value in cents
  eventData: text("event_data"), // JSON with additional event information
  sessionId: text("session_id"),
  userId: varchar("user_id").references(() => users.id),
  timestamp: timestamp("timestamp").notNull().defaultNow(),
});

export const affiliateLeaderboard = pgTable("affiliate_leaderboard", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  agencyId: varchar("agency_id").notNull().references(() => travelAgencies.id),
  affiliateProgramId: varchar("affiliate_program_id").notNull().references(() => affiliatePrograms.id),
  partnerType: text("partner_type").notNull(), // travel_agency, individual_user
  period: text("period").notNull(), // monthly, quarterly, yearly
  periodStart: timestamp("period_start").notNull(),
  periodEnd: timestamp("period_end").notNull(),
  scope: text("scope").notNull().default("global"), // global, country, region, territory
  countryCode: text("country_code"), // For country-specific rankings
  region: text("region"), // For regional rankings
  rank: integer("rank").notNull(),
  partnerTypeRank: integer("partner_type_rank"), // Ranking within partner type (agency vs user leaderboards)
  nationalRank: integer("national_rank"), // Ranking within country
  regionalRank: integer("regional_rank"), // Ranking within region
  totalReferrals: integer("total_referrals").notNull(),
  convertedReferrals: integer("converted_referrals").notNull(),
  totalRevenue: integer("total_revenue").notNull(), // in cents
  commissionEarned: integer("commission_earned").notNull(), // in cents
  conversionRate: decimal("conversion_rate", { precision: 5, scale: 4 }),
  averageOrderValue: integer("average_order_value"), // in cents
  topPerformerBadge: text("top_performer_badge"), // gold, silver, bronze, rising_star (different criteria for agencies vs users)
  achievements: text("achievements").array(), // JSON array of earned badges/achievements
  territoryDominance: decimal("territory_dominance", { precision: 5, scale: 4 }), // % market share in territory
  crossBorderReferrals: integer("cross_border_referrals"), // International referrals
  businessImpactScore: decimal("business_impact_score", { precision: 5, scale: 2 }), // Higher weight for travel agency contributions
  createdAt: timestamp("created_at").defaultNow(),
});

// Country Operations Management
export const countryOperations = pgTable("country_operations", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  countryCode: text("country_code").notNull().unique(),
  countryName: text("country_name").notNull(),
  region: text("region").notNull(), // North America, Europe, Asia, etc.
  currency: text("currency").notNull(), // USD, EUR, JPY, etc.
  timezone: text("timezone").notNull(),
  language: text("language").notNull(),
  totalAgencies: integer("total_agencies").notNull().default(0),
  targetAgencies: integer("target_agencies").notNull().default(360),
  activeAgencies: integer("active_agencies").notNull().default(0),
  territoryDivisions: integer("territory_divisions").notNull().default(36), // 36 territories of ~10 agencies each
  marketPenetration: decimal("market_penetration", { precision: 5, scale: 4 }), // 0.0000 to 1.0000
  averageCommissionRate: decimal("average_commission_rate", { precision: 5, scale: 4 }),
  totalRevenue: integer("total_revenue").notNull().default(0), // in cents
  monthlyGrowth: decimal("monthly_growth", { precision: 5, scale: 4 }),
  competitorAnalysis: text("competitor_analysis"), // JSON with market insights
  regulatoryStatus: text("regulatory_status").notNull().default("compliant"), // compliant, pending, restricted
  launchDate: timestamp("launch_date"),
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

// Territory Management for Geographic Distribution
export const territoryManagement = pgTable("territory_management", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  countryCode: text("country_code").notNull().references(() => countryOperations.countryCode),
  territoryCode: text("territory_code").notNull(), // T001-T360 per country
  territoryName: text("territory_name").notNull(),
  region: text("region"), // State/Province/Region
  majorCities: text("major_cities").array(), // ["New York", "Brooklyn", "Queens"]
  coordinates: text("coordinates"), // JSON with territory boundaries
  populationSize: integer("population_size"),
  targetAgencies: integer("target_agencies").notNull().default(10), // ~10 agencies per territory
  assignedAgencies: integer("assigned_agencies").notNull().default(0),
  maxCapacity: integer("max_capacity").notNull().default(500), // Max users this territory can serve
  currentLoad: integer("current_load").notNull().default(0),
  marketTier: text("market_tier").notNull(), // tier1, tier2, tier3
  competitiveness: text("competitiveness").notNull(), // high, medium, low
  averageIncome: integer("average_income"), // Territory demographic data
  tourismScore: decimal("tourism_score", { precision: 3, scale: 2 }), // Tourism activity rating
  seasonalPeaks: text("seasonal_peaks").array(), // ["summer", "winter", "holidays"]
  territoryManager: text("territory_manager"), // Assigned manager contact
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

// Service reviews system
export const services = pgTable("services", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  description: text("description").notNull(),
  category: text("category").notNull(), // travel_agency, tour_package, affiliate_program
  providerId: varchar("provider_id"), // Generic provider ID (agency, user, etc.)
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

export const reviews = pgTable("reviews", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id),
  serviceId: varchar("service_id").notNull().references(() => services.id),
  rating: integer("rating").notNull(), // 1-5 stars
  title: text("title"),
  comment: text("comment"),
  isVerified: boolean("is_verified").notNull().default(false),
  isAnonymous: boolean("is_anonymous").notNull().default(false),
  helpfulVotes: integer("helpful_votes").notNull().default(0),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Insert schemas
export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
  level: true,
  totalMissionsCompleted: true,
});

export const insertMissionSchema = createInsertSchema(missions).omit({
  id: true,
  createdAt: true,
});

export const insertUserMissionSchema = createInsertSchema(userMissions).omit({
  id: true,
  createdAt: true,
});

export const missionVerificationSchema = z.object({
  proofType: z.enum(["photo", "text", "location", "none"]),
  proofData: z.string().optional(),
  location: z.object({
    latitude: z.number(),
    longitude: z.number(),
    accuracy: z.number().optional(),
  }).optional(),
  additionalData: z.record(z.any()).optional(),
});

export const insertLotterySchema = createInsertSchema(lotteries).omit({
  id: true,
  createdAt: true,
  soldTickets: true,
  winnerId: true,
});

export const insertLotteryTicketSchema = createInsertSchema(lotteryTickets).omit({
  id: true,
  ticketCode: true,
  purchasedAt: true,
  isWinningTicket: true,
  winnerQrCode: true,
});



export const insertNftSchema = createInsertSchema(nfts).omit({
  id: true,
  createdAt: true,
  tokenId: true,
});

export const insertPrizeSchema = createInsertSchema(prizes).omit({
  id: true,
  createdAt: true,
});

export const insertPrizeRedemptionSchema = createInsertSchema(prizeRedemptions).omit({
  id: true,
  redeemedAt: true,
  redemptionCode: true,
});

export const insertTokenPackSchema = createInsertSchema(tokenPacks).omit({
  id: true,
  createdAt: true,
});

export const insertTokenPurchaseSchema = createInsertSchema(tokenPurchases).omit({
  id: true,
  purchasedAt: true,
});

// New Viator/Kairos/Raivan token system Zod schemas
export const insertRaivanConversionSchema = createInsertSchema(raivanConversions).omit({
  id: true,
  createdAt: true,
});

export const insertViatorTokenPackSchema = createInsertSchema(viatorTokenPacks).omit({
  id: true,
  createdAt: true,
});

export const insertRaivanActivitySchema = createInsertSchema(raivanActivities).omit({
  id: true,
  createdAt: true,
});

export const insertUserConversionLimitSchema = createInsertSchema(userConversionLimits).omit({
  id: true,
  createdAt: true,
});

export const insertAchievementSchema = createInsertSchema(achievements).omit({
  id: true,
  createdAt: true,
});

export const insertUserAchievementSchema = createInsertSchema(userAchievements).omit({
  id: true,
  createdAt: true,
});

export const insertServiceConditionSchema = createInsertSchema(serviceConditions).omit({
  id: true,
  createdAt: true,
});

export const insertUserAgreementSchema = createInsertSchema(userAgreements).omit({
  id: true,
  createdAt: true,
});

export const insertServiceSchema = createInsertSchema(services).omit({
  id: true,
  createdAt: true,
});

export const insertReviewSchema = createInsertSchema(reviews).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  helpfulVotes: true,
});

export const insertTravelAgencySchema = createInsertSchema(travelAgencies).omit({
  id: true,
  createdAt: true,
  totalBookings: true,
});

export const insertAgencyTourPackageSchema = createInsertSchema(agencyTourPackages).omit({
  id: true,
  createdAt: true,
});

export const insertPrizeWinnerSchema = createInsertSchema(prizeWinners).omit({
  id: true,
  createdAt: true,
  claimedAt: true,
  assignedAt: true,
  contactedAt: true,
  bookedAt: true,
  completedAt: true,
});

export const insertAgencyCommissionSchema = createInsertSchema(agencyCommissions).omit({
  id: true,
  createdAt: true,
  approvedAt: true,
  paidAt: true,
});

export const insertAgencyAnalyticsSchema = createInsertSchema(agencyAnalytics).omit({
  id: true,
  createdAt: true,
});

export const insertAffiliateProgramSchema = createInsertSchema(affiliatePrograms).omit({
  id: true,
  createdAt: true,
  affiliateLink: true, // Generated automatically
  uniqueCode: true, // Generated automatically
});

export const insertAffiliateReferralSchema = createInsertSchema(affiliateReferrals).omit({
  id: true,
  createdAt: true,
  clickedAt: true, // Set automatically
});

export const insertAffiliatePayoutSchema = createInsertSchema(affiliatePayouts).omit({
  id: true,
  createdAt: true,
  approvedAt: true,
  paidAt: true,
});

export const insertAffiliateTrackingEventSchema = createInsertSchema(affiliateTrackingEvents).omit({
  id: true,
  timestamp: true, // Set automatically
});

export const insertAffiliateLeaderboardSchema = createInsertSchema(affiliateLeaderboard).omit({
  id: true,
  createdAt: true,
});

export const insertUserFavoriteSchema = createInsertSchema(userFavorites).omit({
  id: true,
  createdAt: true,
});

export const insertCountryOperationSchema = createInsertSchema(countryOperations).omit({
  id: true,
  createdAt: true,
});

export const insertTerritoryManagementSchema = createInsertSchema(territoryManagement).omit({
  id: true,
  createdAt: true,
});

// Types
export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;

export type Mission = typeof missions.$inferSelect;
export type InsertMission = z.infer<typeof insertMissionSchema>;

export type UserMission = typeof userMissions.$inferSelect;
export type InsertUserMission = z.infer<typeof insertUserMissionSchema>;

export type Lottery = typeof lotteries.$inferSelect;
export type InsertLottery = z.infer<typeof insertLotterySchema>;

export type LotteryTicket = typeof lotteryTickets.$inferSelect;
export type InsertLotteryTicket = z.infer<typeof insertLotteryTicketSchema>;

export type Prize = typeof prizes.$inferSelect;
export type InsertPrize = z.infer<typeof insertPrizeSchema>;

export type PrizeRedemption = typeof prizeRedemptions.$inferSelect;
export type InsertPrizeRedemption = z.infer<typeof insertPrizeRedemptionSchema>;

export type TokenPack = typeof tokenPacks.$inferSelect;
export type InsertTokenPack = z.infer<typeof insertTokenPackSchema>;

export type TokenPurchase = typeof tokenPurchases.$inferSelect;
export type InsertTokenPurchase = z.infer<typeof insertTokenPurchaseSchema>;

// New Viator/Kairos/Raivan token system types
export type RaivanConversion = typeof raivanConversions.$inferSelect;
export type InsertRaivanConversion = z.infer<typeof insertRaivanConversionSchema>;

export type ViatorTokenPack = typeof viatorTokenPacks.$inferSelect;
export type InsertViatorTokenPack = z.infer<typeof insertViatorTokenPackSchema>;

export type RaivanActivity = typeof raivanActivities.$inferSelect;
export type InsertRaivanActivity = z.infer<typeof insertRaivanActivitySchema>;

export type UserConversionLimit = typeof userConversionLimits.$inferSelect;
export type InsertUserConversionLimit = z.infer<typeof insertUserConversionLimitSchema>;

export type Achievement = typeof achievements.$inferSelect;
export type InsertAchievement = z.infer<typeof insertAchievementSchema>;

export type UserAchievement = typeof userAchievements.$inferSelect;
export type InsertUserAchievement = z.infer<typeof insertUserAchievementSchema>;

export type TravelAgency = typeof travelAgencies.$inferSelect;
export type InsertTravelAgency = z.infer<typeof insertTravelAgencySchema>;

export type ServiceCondition = typeof serviceConditions.$inferSelect;
export type InsertServiceCondition = z.infer<typeof insertServiceConditionSchema>;

export type UserFavorite = typeof userFavorites.$inferSelect;
export type InsertUserFavorite = z.infer<typeof insertUserFavoriteSchema>;

export const insertLotteryDrawSchema = createInsertSchema(lotteryDraws).omit({
  id: true,
  drawnAt: true,
});
export type LotteryDraw = typeof lotteryDraws.$inferSelect;
export type InsertLotteryDraw = z.infer<typeof insertLotteryDrawSchema>;

export const insertMissionActivitySchema = createInsertSchema(missionActivities).omit({
  id: true,
  activityId: true,
  createdAt: true,
});
export type MissionActivity = typeof missionActivities.$inferSelect;
export type InsertMissionActivity = z.infer<typeof insertMissionActivitySchema>;
export type MissionVerification = z.infer<typeof missionVerificationSchema>;

export type NFT = typeof nfts.$inferSelect;
export type InsertNFT = z.infer<typeof insertNftSchema>;

export type UserAgreement = typeof userAgreements.$inferSelect;
export type InsertUserAgreement = z.infer<typeof insertUserAgreementSchema>;

export type Service = typeof services.$inferSelect;
export type InsertService = z.infer<typeof insertServiceSchema>;

export type Review = typeof reviews.$inferSelect;
export type InsertReview = z.infer<typeof insertReviewSchema>;

export type AgencyTourPackage = typeof agencyTourPackages.$inferSelect;
export type InsertAgencyTourPackage = z.infer<typeof insertAgencyTourPackageSchema>;

export type PrizeWinner = typeof prizeWinners.$inferSelect;
export type InsertPrizeWinner = z.infer<typeof insertPrizeWinnerSchema>;

export type AgencyCommission = typeof agencyCommissions.$inferSelect;
export type InsertAgencyCommission = z.infer<typeof insertAgencyCommissionSchema>;

export type AgencyAnalytics = typeof agencyAnalytics.$inferSelect;
export type InsertAgencyAnalytics = z.infer<typeof insertAgencyAnalyticsSchema>;

export type AffiliateProgram = typeof affiliatePrograms.$inferSelect;
export type InsertAffiliateProgram = z.infer<typeof insertAffiliateProgramSchema>;

export type AffiliateReferral = typeof affiliateReferrals.$inferSelect;
export type InsertAffiliateReferral = z.infer<typeof insertAffiliateReferralSchema>;

export type AffiliatePayout = typeof affiliatePayouts.$inferSelect;
export type InsertAffiliatePayout = z.infer<typeof insertAffiliatePayoutSchema>;

export type AffiliateTrackingEvent = typeof affiliateTrackingEvents.$inferSelect;
export type InsertAffiliateTrackingEvent = z.infer<typeof insertAffiliateTrackingEventSchema>;

export type AffiliateLeaderboard = typeof affiliateLeaderboard.$inferSelect;
export type InsertAffiliateLeaderboard = z.infer<typeof insertAffiliateLeaderboardSchema>;

export type CountryOperation = typeof countryOperations.$inferSelect;
export type InsertCountryOperation = z.infer<typeof insertCountryOperationSchema>;

export type TerritoryManagement = typeof territoryManagement.$inferSelect;
export type InsertTerritoryManagement = z.infer<typeof insertTerritoryManagementSchema>;

// Marketplace Selling and Auction Zod Schemas
export const insertMarketplaceListingSchema = createInsertSchema(marketplaceListings).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  currentPrice: true,
  totalViews: true,
  totalWatchers: true,
});

export const insertMarketplaceBidSchema = createInsertSchema(marketplaceBids).omit({
  id: true,
  createdAt: true,
});

export const insertMarketplacePurchaseSchema = createInsertSchema(marketplacePurchases).omit({
  id: true,
  createdAt: true,
  completedAt: true,
  transferCode: true,
});

export const insertMarketplaceWatcherSchema = createInsertSchema(marketplaceWatchers).omit({
  id: true,
  createdAt: true,
});

export const insertSellerProfileSchema = createInsertSchema(sellerProfiles).omit({
  id: true,
  joinedAsSellerAt: true,
  lastActiveAt: true,
});

export const insertMarketplaceDisputeSchema = createInsertSchema(marketplaceDisputes).omit({
  id: true,
  createdAt: true,
  resolvedAt: true,
});

export const insertItemVerificationSchema = createInsertSchema(itemVerifications).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Marketplace Types
export type MarketplaceListing = typeof marketplaceListings.$inferSelect;
export type InsertMarketplaceListing = z.infer<typeof insertMarketplaceListingSchema>;

export type MarketplaceBid = typeof marketplaceBids.$inferSelect;
export type InsertMarketplaceBid = z.infer<typeof insertMarketplaceBidSchema>;

export type MarketplacePurchase = typeof marketplacePurchases.$inferSelect;
export type InsertMarketplacePurchase = z.infer<typeof insertMarketplacePurchaseSchema>;

export type MarketplaceWatcher = typeof marketplaceWatchers.$inferSelect;
export type InsertMarketplaceWatcher = z.infer<typeof insertMarketplaceWatcherSchema>;

export type SellerProfile = typeof sellerProfiles.$inferSelect;
export type InsertSellerProfile = z.infer<typeof insertSellerProfileSchema>;

export type MarketplaceDispute = typeof marketplaceDisputes.$inferSelect;
export type InsertMarketplaceDispute = z.infer<typeof insertMarketplaceDisputeSchema>;

export type ItemVerification = typeof itemVerifications.$inferSelect;
export type InsertItemVerification = z.infer<typeof insertItemVerificationSchema>;
